线程的生命周期
    1、新建状态
    2、就绪状态start（）;使用这个方法，这个方法执行了表示当前线程类是可执行的状态
        具有抢夺cpu时间片的权利。
    3、运行状态当线程执行run();的时候表示线程进入运行状态，当时间片时间用完的时候还会回到就绪的状态
        继续等待去抢时间片去执行，接着上一次的代码继续执行。
    4、阻塞状态当线程遇见阻塞的时候例如接受键盘的输入，或者sleep（）; wait();的方法，阻塞的时候
        会放弃原先占有时间片，回到就绪状态等待强到时间片执行。
    5、死亡状态最后执行完了就等于死亡了drop();destroy();等方法的执行。

线程中的方法
    1、实例方法(对象的方法去调用)
        join(); 合并所在的线程受阻，直到调用它的线程执行完，才执行所在线程
        start();
        run();
        setPriority();
        getPriority();
        interrupt();
    2、静态方法（调用的时候需要再需要使用的线程中Thread.的方式去调用）
        sleep();
        wait();
        currentThread();
        yield(); 表示降级的意思，降低线程执行的优先权，暂停当前线程，执行别线程，从run到start，不属于线程阻塞，还有可能再一次的强到时间片
线程的的调度
    1、抢占式  java采用的，风优先级
        1、1 最低的优先级是1，最高的优先级5，默认的优先级10
                设置优先级和获取优先级别
                    getPriority();
                    setPriority();
                    yield();
    2、均分式  平均的分配cpu时间片
多线的安全 **********************************重点**********************
    1、什么时候会存在线程的安全问题呢？
        1 多线的并发条件下
        2 有共享数据的时候，并且共享数据修改了。
    2、怎么解决线程安全问题呢？
        1 实现线程的排队执行，会损失程序的执行效率，只有再保证数据的安全的前提下才能
            考虑执行的效率，解决线程的安全的问题体采取  同步 synchronization。
    3、编程模型（引入）
        1 异步编程模型model
            就是线程的并发
        2 同步编程模型model
            就是线程的同步synchronization
线程锁
    synchronized(需要锁的对象){}的使用
    锁的就是{}这里面的代码块
    *********************************只用对象共享才会触发锁**************************
三大变量的线程安全问题
    1、静态变量 ：使用类锁
    2、局部变量 ：存储在栈中不存在线程安全问题，每一线程对应一个栈，局部变量不共享
    3、实例变量
synchronized的三种写法
    1、synchronized(要同步的对象){
            同步代码块
            }  同步代码块
    2、public synchronized void doSome(){}
        表示的共享对象一定会是this，同步的是一整个的方法
    3、在静态的方法中使用synchronized
        表示找类锁
        类锁永远的只有一把
        创建100个对象，那类所只有一个
        对象锁 ： 一个对象一个锁，100个对象100个锁
        类锁 ： 100个对象也只有可能只有一把类锁
死锁
    1、触发死锁的条件是什么！如何解决死锁的问题
        条件：
            * 有共享对象的时候
            * synchronized(){
                synchronized(){
                    }
                }
        解决:
            个人认为可以使用睡眠的方式或者使用join方法来实现排队
线程还剩下的一些内容
    1、守护的问题
        1.1java中的线程分为两大类
             一类 ： 用户线程
             二类 ： 守护线程（后台线程）
                其中垃圾回收器就是守护线程
              守护线程的特点：
                    一般的守护线程是一个死循环，只要用户线程一结束，守护线程就结束
                    注意 ： main线程是用户线程
    2、定时器
    3、实现线程的第三种方式 FutureTask方法，实现Callable接口。
    4、Object类中的wait方法和notify方法（生产者和消费者模式）