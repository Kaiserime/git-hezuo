线程的生命周期
    1、新建状态
    2、就绪状态start（）;使用这个方法，这个方法执行了表示当前线程类是可执行的状态
        具有抢夺cpu时间片的权利。
    3、运行状态当线程执行run();的时候表示线程进入运行状态，当时间片时间用完的时候还会回到就绪的状态
        继续等待去抢时间片去执行，接着上一次的代码继续执行。
    4、阻塞状态当线程遇见阻塞的时候例如接受键盘的输入，或者sleep（）; wait();的方法，阻塞的时候
        会放弃原先占有时间片，回到就绪状态等待强到时间片执行。
    5、死亡状态最后执行完了就等于死亡了drop();destroy();等方法的执行。

线程中的方法
    1、实例方法(对象的方法去调用)
        join(); 合并所在的线程受阻，直到调用它的线程执行完，才执行所在线程
        start();
        run();
        setPriority();
        getPriority();
        interrupt();
    2、静态方法（调用的时候需要再需要使用的线程中Thread.的方式去调用）
        sleep();
        wait();
        currentThread();
        yield(); 暂停当前线程，执行别线程，从run到start，不属于线程阻塞，还有可能再一次的强到时间片
线程的的调度
    1、抢占式  java采用的，风优先级
        1、1 最低的优先级是1，最高的优先级5，默认的优先级10
                设置优先级和获取优先级别
                    getPriority();
                    setPriority();
                    yield();
    2、均分式  平均的分配cpu时间片
多线的安全 **********************************重点**********************
    1、什么时候会存在线程的安全问题呢？
        1 多线的并发条件下
        2 有共享数据的时候，并且共享数据修改了。
    2、怎么解决线程安全问题呢？
        1 实现线程的排队执行，会损失程序的执行效率，只有再保证数据的安全的前提下才能
            考虑执行的效率，解决线程的安全的问题体采取  同步 synchronization。
    3、编程模型（引入）
        1 异步编程模型model
            就是线程的并发
        2 同步编程模型model
            就是线程的同步synchronization



